# 类实现

### 继承

[C++](http://c.biancheng.net/cplus/)继承的一般语法为：

class 派生类名:［继承方式］ 基类名{
  派生类新增加的成员
};

继承方式限定了基类成员在派生类中的访问权限，包括 public（公有的）、private（私有的）和 protected（受保护的）。此项是可选项，如果不写，默认为 private（成员变量和成员函数默认也是 private）。

现在我们知道，public、protected、private 三个关键字除了可以修饰类的成员，还可以指定继承方式。

## public、protected、private 修饰类的成员

类成员的访问权限由高到低依次为 public --> protected --> private，我们在《[C++类成员的访问权限以及类的封装](http://c.biancheng.net/view/2217.html)》一节中讲解了 public 和 private：public 成员可以通过对象来访问，private 成员不能通过对象访问。

现在再来补充一下 protected。protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用，下面是详细讲解。

## public、protected、private 指定继承方式

不同的继承方式会影响基类成员在派生类中的访问权限。

**1) public继承方式**

- 基类中所有 public 成员在派生类中为 public 属性；
- 基类中所有 protected 成员在派生类中为 protected 属性；
- 基类中所有 private 成员在派生类中不能使用。


**2) protected继承方式**

- 基类中的所有 public 成员在派生类中为 protected 属性；
- 基类中的所有 protected 成员在派生类中为 protected 属性；
- 基类中的所有 private 成员在派生类中不能使用。


**3) private继承方式**

- 基类中的所有 public 成员在派生类中均为 private 属性；
- 基类中的所有 protected 成员在派生类中均为 private 属性；
- 基类中的所有 private 成员在派生类中不能使用。


通过上面的分析可以发现：
\1) 基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为 protected 时，那么基类成员在派生类中的访问权限最高也为 protected，高于 protected 的会降级为 protected，但低于 protected 不会升级。再如，当继承方式为 public 时，那么基类成员在派生类中的访问权限将保持不变。

也就是说，继承方式中的 public、protected、private 是用来指明基类成员在派生类中的最高访问权限的。

\2) 不管继承方式如何，基类中的 private 成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。

\3) 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为 public 或 protected；只有那些不希望在派生类中使用的成员才声明为 private。

\4) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。

注意，我们这里说的是基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。



| 继承方式/基类成员 | public成员 | protected成员 | private成员 |
| ----------------- | ---------- | ------------- | ----------- |
| public继承        | public     | protected     | 不可见      |
| protected继承     | protected  | protected     | 不可见      |
| private继承       | private    | private       | 不可见      |

公有继承：







保护继承protected

继承的访问控制：
基类的public成员和protected都以protected出现在派生类中。

基类的private成员不可直接访问。

访问权限：
派生类的成员函数可以直接访问基类中的public和protected成员，但布恩那个直接访问基类的private成员。

通过派生类的对象，不能直接访问从基类继承的任何成员。

protected成员的特点与作用

对于建立所在类的对象来说，他与private成员的性质相同。

对于其派生类来说，他与public成员的性质相同。

## 类型转换

公有派生：

将派生类的对象转换为基类对象或指针，只能访问基类的公有成员。

![image-20210817161701567](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817161701567.png)

## 派生类构造函数

基类构造函数不被继承

派生类需要定义自己的构造函数

派生类构造函数需要向基类传递参数，保证基类构造。

using 实现基类构造函数继承。

派生类的构造函数需要给基类的构造函数传递参数。

派生类名：：派生类名（基类所需的形参，本类成员的形参）

构造函数的执行过程：

先构造基类，在构造派生类。

组合类：

派生类名：：派生类名（形参表）：

基类名1（参数），基类名2（参数），

本类成员（含对象成员）初始化列表

{

//其他初始化

}；

构造函数调用次序：

1、调用基类构造函数，

顺序按照他们被继承时声明的顺序（从左向右）

2、对初始化列表中的成员进行初始化。

顺序按照它们在类中定义的顺序。

对象成员初始化时自动调用其所属类的构造函数。

 由初始化列表提供参数。

3、执行派生类的构造函数体中的内容。

## 派生类的复制构造函数

1、派生类没有声明复制构造函数：

编译器会在需要时生成一个隐含的复制构造函数

先调用基类的复制构造函数

在位派生类新增的成员执行复制

2、派生类定义复制构造函数：

为基类复制构造函数传递参数

复制构造寒素只能接受一个参数，及用来初始化派生类定义的成员，也将被传递给基类的复制构造函数。

基类的复制构造函数形参类型时基类对象的引用，实参类型可以是派生类对象的引用。

## 派生类的析构函数

析构函数不被继承

先执行继承类析构，再调用基类析构函数。

与构造时候的顺序相反。

## 访问从基类继承的成员

1、派生类与基类有相同的成员

若未特比限定，则通过派生类对象使用的时派生类中的同名成员

若要通过派生类访问基类中被隐藏的同名成员，应使用积累名和作用域运算符：：限定。

2、多个继承存在相同成员

存在二义性，使用作用域运算符指定

## 虚基类

当派生类从多个基类派生，而这些基类又存在共同基类，则在访问此共同基类的成员时，将产生冗余，并由肯带来不一致问题。

![image-20210817161138548](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817161138548.png)

![image-20210817161228362](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817161228362.png)

![image-20210817161303626](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817161303626.png)

![image-20210817161413029](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817161413029.png)

![image-20210817161449585](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817161449585.png)

![image-20210817161508320](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817161508320.png)

base0的构造函数只被调用一次。

# 重载

多态的概念，操作接口具有多种不同的形态。

## 运算符重载

![image-20210817163655187](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817163655187.png)

有的运算符不能作为成员函数

前置运算符与后置运算符
前置运算符：运算符在变量前面，先进行运算，再进行存储
后置运算符：运算符在变量后面，先进行存储，再进行运算
在各语言中前置运算符和后置运算符性质均相同，这里将用C语言来进行解释

#include<stdio.h>

int main(){
	int a;
	++a;		//这是前置运算
	a++;		//这是后置运算
	printf("%d\n",a);
}

函数的重载
运算符重载
运算符重载的作用
运算符重载的规则
运算符重载的方式
方式(1) 作为类成员函数
方式2：作为类的友元函数
方式3：既非类的成员函数也不是友元函数的普通函数
典型运算符的重载
双目运算符的重载
单目运算符重载
流运算符的重载
赋值运算符重载 “=”
转换构造函数
类型转换函数
函数的重载
函数重载是指完成不同功能的函数可以具有相同的函数名。
C++编译器根据函数的实参确定应该调用哪一个函数。

1.定义的重载函数必须具有不同的参数个数，或不同的参数类型。编译系统根据不同的参数去调用不同的重载函数，实现不同的功能。
2、仅返回值不同时，不能定义为重载函数。

运算符重载
运算符重载的作用
重新定义的运算符称为运算符的重载。
运算符重载赋予已有的运算符多重含义或新的功能。C++通过重新定义运算符，使它能够用于特定的对象，执行特定的功能
用一个经典的例子说明这个情况

用运算符重载实现两个复数相加
class Complex{
private:
    double real,imag;
public:
    Complex(double r=0,double i=0):real(r),imag(i){}
    void display()const{cout<<real<<" , "<<imag<<"i"<<endl;}
    Complex(const Complex &c){real = c.real;imag = c.imag;}
    Complex operator+(const Complex &c2);
};

Complex Complex::operator+(const Complex &c2){
    Complex c;
    c.real = real+c2.real;
    c.imag = imag+c2.imag;
    return c;
}

/*//也可以利用无名对象
Complex Complex::operator+(const Complex &c2){
    return Complex(real+c2.real,imag+c2.imag);
}
*/

int main(){
    Complex c1(1,2);
    Complex c2(2,5);
    Complex c3 = c1+c2;
    c3.display();
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
为了重载运算符，必须定义一个函数，告诉编译器，遇到这个重载运算符就调用该函数，由这个函数来完成该运算符应该完成的操作，这种函数称为运算符重载函数，它通常是类的成员函数或者是友元函数。运算符的操作数通常是类的对象。

运算符重载对C++有重要的意义：
本来C++提供的运算符只能用于C++的标准数据类型，不能用于用户自己定义的类对象，影响了类和对象的使用。
C++不是为类对象另外定义一批新的运算符，只允许重载现有的运算符，使这些简单易用、众所周知的运算符能够直接用于类对象。

运算符重载使C++具有更强大的功能、更好的可扩充性和适应性。
运算符重载的规则
<返回类型> operator<运算符>(<参数表>)
{函数体}
A operator+(A &);
1
2
3
operator是定义运算符重载函数的关键字，它与其后的运算符一起构成函数名。

只能对C++中已有的运算符进行重载。
在C++中允许重载的运算符如下


C++中不能重载的运算符只有5个：
. (成员访问运算符)
.* (成员指针访问运算符)
∷ (域运算符)
sizeof (长度运算符)
?: (条件运算符)

重载不能改变运算符的优先级、结合性、运算对象(即操作数)的个数。
重载运算符的函数不能有默认的参数，否则就改变了运算符参数的个数。
class room{
    float Length;
    float Wide;
public:
    room(float a=0.0,float b=0.0){   Length=a;    Wide=b; }
    void Show(void) {cout<<"Length="<<Length<<'\t'<<"Wide="<<Wide<<endl;}
    void ShowArea(void) { cout<<"Area="<<Length*Wide<<endl;    }
    room operator+(room &);//重载运算符+，函数原型
};
room room::operator + (room &r)   //重载运算符函数
{   room rr;
    rr.Length =Length+r.Length;
    rr.Wide =Wide+r.Wide ;
    return rr;
}
int main(void)
{   room r1(3,2),r2(1,4), r3,r4,r5;
    r1.Show ();    r2.Show ();
    r3=r1+r2;
    r3.Show ();
    r4=r1+r2+r3; //运算顺序：(r1+r2)， (r1+r2)+r3
    r4.Show ();
    r5=r1+(r2+r3); //报错！！！
    r5.Show();
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象(或类对象的引用)。
参数不能全部是C++的标准类型，以防止用户修改用于标准数据类型的运算符。
有两个运算符一般不需要重载：

①赋值运算符(=)可以用于每一个类对象，利用它在同类对象之间相互赋值。(也有必须重载的情况)
②地址运算符&也不必重载，它能返回类对象在内存中的起始地址。
运算符重载的方式
方式(1) 作为类成员函数
当用成员函数实现运算符的重载时，运算符重载函数的参数只能有二种情况：
没有参数；
带有一个参数。

对于只有一个操作数的运算符，在重载这种运算符时，通常不能有参数；
对于有二个操作数的运算符，只能带有一个参数。这个参数可以是对象、对象的引用或其它类型的参数。
用成员函数实现运算符的重载时**，运算符的左操作数为当前对象**，这是一个隐含的函数参数，要用到隐含的this指针；

c = a+b ; c = a.operator+(b);
c += a  ; c.operator+=(a);
c = ++a ; c = a.operator++();
1
2
3
class A{
public:
	int x ;
	A(int x):x(x){}
};
a + b ;
实际上为 a.operator+(b);

A operator+(A&b)
{
	return(this->x+b.x)
} 
1
2
3
4
5
6
7
8
9
10
11
12
运算符重载函数不能定义为静态的成员函数，因为静态的成员函数中没有this指针。

demo

class A
{    int i;
public:     A(int a=0){ i=a;    }
    void Show(void){    cout<<"i="<<i<<endl;    }
    A operator +(A &a){
        A   t;
        t.i=i+a.i;
        return t;
    }
    A operator+=(A &a){
        i=i+a.i;
        return *this;  //修改这个对象的成员数据后，再返回
    }
};

int main(void)
{    A a1(10),a2(20),a3;
    a1.Show ();
    a2.Show ();
    a3=a1+a2;
    a3.Show ();
    a1+=a2;  // int a1,a2; a1+=a2就相当于 a1=a1+a2;
    a1.Show ();
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
方式2：作为类的友元函数
友元函数是在类外的普通函数，与一般函数的区别是可以调用类中的私有或保护数据。

friend <类的类型> operator<运算符>（<参数表>）
{……}

friend A operator+(A &a,A &b)
{……}
c = a+b; //c = operator+(a,b);
1
2
3
4
5
6
将运算符重载函数定义为友元函数，参与运算的对象全部成为函数参数。
(没有隐含的this指针了)

注意和上面的区别!!!

c = a+b; c = operator+(a,b);
c += a; operator+=(c,a);
c = ++a; c = operator++(a); 
1
2
3
对单目运算符，友元函数有一个参数。
对双目运算符，友元函数有2个参数。

还是用上面的复数相加的例子:

将运算符“+”重载为适用于复数加法，重载函数不作为成员函数，而放在类外，作为Complex类的友元函数。

class Complex{
private:
    double real,imag;
public:
    Complex(double r=0,double i=0):real(r),imag(i){}
    void display()const{cout<<real<<" , "<<imag<<"i"<<endl;}

    friend Complex operator+(const Complex &,const Complex &);
};

Complex operator+(const Complex &c1,const Complex &c2){
    //声明了为友元，可以使用Complex的私有数据
    return Complex(c1.real+c2.real,c1.imag+c2.imag);
}


int main(){
    Complex c1(1,2),c2(2,5);
    Complex c3 = c1+c2;
    c3.display();
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
方式3：既非类的成员函数也不是友元函数的普通函数
只有在极少的情况下才使用既不是类的成员函数也不是友元函数的普通函数(一般不用)，因为普通函数不能直接访问类的私有成员。

仍然以上面的复数类为例
考虑这样的情形：

Complex c3 = 2+c2;// 不合法
只能写作：
Complex c3 = Complex(2,0)+c2; 
1
2
3
那如果就像使这种写法可行呢

可以这样重载:

friend Complex operator+(int r,Complex &c);
Complex operator+(int r,Comlex &c)
{
	return Complex(r+c.real,c.imag);
}
1
2
3
4
5
注意这里的加法交换律并不默认处理，
如果需要，再重载一次就可。

friend Complex operator+(Complex &c，int r);
Complex operator+(Comlex &c，int r)
{
	return Complex(r+c.real,c.imag);
}
1
2
3
4
5
C++规定，赋值运算符=、下标运算符[]、函数调用运算符()、成员运算符-> 必须定义为类的成员函数。

流插入运算符<<、流提取运算符>>、类型转换运算符不能定义为类的成员函数，只能作为友元函数。

典型运算符的重载
双目运算符的重载
常用的有：

< > <= >= + - * / %
1
记双目运算符为 B

重载为类的成员函数
a1 B a2 相当于 a1.operatorB(a2);
1
重载为类的友元函数
a1 B a2 相当于 operatorB(a1,a2);
1
单目运算符重载
常用的有

! - & *  ++  --
1
注意：

b = ++a;
b = a++;
1
2
虽然++运算后对象a的值一致，但先自加或后自加的函数的返回值不一致，必须在重载时予以区分。

++为前置运算时，成员函数重载的一般格式
<type> operator++()
{……}
1
2
++为后置运算时，成员函数重载的一般格式
<type> operator++(int)
{……}
1
2
class Complex{
private:
    double real,imag;
public:
    Complex(double r=0,double i=0):real(r),imag(i){}
    void display()const{cout<<real<<" , "<<imag<<"i"<<endl;}
    //前置++的重载 ++c;
    Complex operator++();
    Complex operator++(int);
};

Complex Complex::operator++(){
    real++;
    imag++;
    return *this;
}

Complex Complex::operator++(int){
    Complex c(*this);  //将当前对象的引用传给复制构造参数
    real++;
    imag++;
    return c;
}



int main(){
    Complex c1(1,2),c2(2,5),c3;
    c3 = c1++;
    c3.display();
    c1.display();
    c3 = ++c2;
    c3.display();
    c2.display();
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
1 , 2i
2 , 3i
3 , 6i
3 , 6i
1
2
3
4
++为前置运算的时候，友元函数重载函数的一般格式
A operator++(A &a)
{……}
1
2
++为后置运算的时候，友元函数重载函数的一般格式
A operator++(A&a,int)
{……}
1
2
class Complex{
private:
    double real,imag;
public:
    Complex(double r=0,double i=0):real(r),imag(i){}
    void display()const{cout<<real<<" , "<<imag<<"i"<<endl;}
    //前置++的重载 ++c;
    friend Complex& operator++(Complex&);
    friend Complex operator++(Complex&,int);
};

//当然此处也可以不返回对象引用，但是耗内存和时间。
Complex& operator++(Complex& c){
    c.real++;
    c.imag++;
    return c;
}

//当然此处绝不返回对象引用，因为c1是临时的副本，生命在函数结束之后被析构
Complex operator++(Complex& c,int){
    Complex c1(c);  //将当前对象的引用传给复制构造参数
    c.real++;
    c.imag++;
    return c1;
}



int main(){
    Complex c1(1,2),c2(2,5),c3;
    c3 = ++c1;
    c1.display();
    c3.display();
    c3 = c2++;
    c2.display();
    c3.display();
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
2 , 3i
2 , 3i
3 , 6i
2 , 5i
1
2
3
4
流运算符的重载
cin和cout分别是istream类和ostream类的对象。在类库提供的头文件中已经对“<<”和“>>”进行了重载，作为流插入运算符和流提取运算符，能用来输出和输入C++标准类型的数据，用#include 包含到自己的程序文件中。

用户自己定义的类型的数据，不能直接用“<<”和“>>”来输出和输入,必须进行重载。

istream & operator >> (istream &, 自定义类 &);
ostream & operator << (ostream &, 自定义类 &);
1
2
只能将重载“>>”和“<<”的函数作为友元函数或普通的函数，而不能将它们定义为成员函数。

原因：
一旦将其重载为类的成员函数，那么左操作数就是调用<<的这个对象，那么operator <<的第一个参数就是这个对象,隐含的this指针，那么就只能这样调用
A << cout。这样显然不是我们要的。

cout<<a 被编译系统解释为
operator<<(cout,a)
1
2
class Complex{
private:
    double real,imag;
public:
    Complex(double r=0,double i=0):real(r),imag(i){}
    friend ostream& operator<<(ostream&,Complex&); //重载 << 插入运算符
    friend istream& operator>>(istream&,Complex&); //重载 >> 插入运算符    
};

ostream& operator<<(ostream& output,Complex& c)
{
    if(c.imag>0)
        output<<"("<<c.real<<"+"<<c.imag<<"i"<<")"<<endl;
    else if(c.imag==0)
        output<<c.real<<endl;
    else
        output<<"("<<c.real<<c.imag<<"i"<<")"<<endl;
    return output;
}

istream& operator>>(istream& input,Complex& c)
{
    cout<<"input  real part and imaginary part of complex number:"<<endl;
    input>>c.real>>c.imag;
    return input;
}

int main(){
    Complex c1;
    cin>>c1;
    cout<<c1;
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
input  real part and imaginary part of complex number:
1 1 //从键盘输入
(1+1i)
1
2
3
return output 的作用
返回cout的当前值，**以便连续输出** 。output是ostream类的对象，它是实参cout的引用，也就是cout通过传送地址给output，二者共享同一段存储单元，或者说**output是cout的别名**。return output就是return cout，将输出流cout返回，即保留输出流的现状。
1
赋值运算符重载 “=”
同类型的对象间可以相互赋值，默认实现是把对象的各个成员一一赋值。注意：与复制构造函数调用方式的不同。

注意：
①②是不一样的，①是调用复制构造函数的简便写法

②是先创建a2对象，再用赋值语句=,这没有调用复制构造函数

①
A a1;
A a2 = a1; //相当于   A a2(a1);
② 
A a1,a2;
a2 = a1;  
1
2
3
4
5
6
说明：
当对象的成员中使用了new开辟空间，
不能直接使用默认的赋值运算符“=”，否则在程序的执行期间会出现运行错误。
这个原因和复制构造函数是一致的。
同一空间释放两次，必须重载。

class  A{
    char *ps;
public:
    A( ){ ps=0;}
    A(const char *s ){ps =new char [strlen(s)+1];  strcpy(ps, s);}
    ~A( ){ if (ps)   delete [] ps;}
    void Show(void) {  cout<<ps<<endl;}
};

int  main(void )
{ A s1("China!"), s2("Computer!");
    s1.Show();
    s2.Show();
    s2=s1; //相当于 s2.ps=s1.ps;
    s1.Show();
    s2.Show();
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
前四行如愿输出

China!
Computer!
China!
China!
CppReview(52520,0x1000d5dc0) malloc: *** error for object 0x10056f560: pointer being freed was not allocated
CppReview(52520,0x1000d5dc0) malloc: *** set a breakpoint in malloc_error_break to debug
1
2
3
4
5
6
重载赋值运算符“＝”

格式

<函数类型> <className>::operator=(<参数表>)

A& A::operator=(A&a)

b = a; 相当于  b.operator=(a); 
1
2
3
4
5
demo

class  A{
    char *ps;
public:
    A( ){ ps=0;}
    A(const char *s ){ps =new char [strlen(s)+1];  strcpy(ps, s);}
    A& operator=(A&);
    ~A( ){ if (ps)   delete [] ps;}
    void Show(void) {  cout<<ps<<endl;}
};

//返回同类型的引用适合于连续赋值
A& A::operator=(A&a)
{
    if(ps) delete []ps;  //这块空间如果不主动delete掉，即使此对象析构，也不会释放
    if(a.ps){
        ps = new char[strlen(a.ps)+1];
        strcpy(ps, a.ps);  // 必须是深复制
    }
    else{
        ps=0;
    }
    return *this;
}

int  main(void )
{ A s1("China!"), s2("Computer!");
    s1.Show();
    s2.Show();
    s2=s1; //相当于 s2.ps=s1.ps;
    s1.Show();
    s2.Show();
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
转换构造函数
数据类型之间的显式类型转换
类型名(数据)
int(10.5)  == 10
1
转换构造函数是将一个其他类型的数据转换成一个类的对象,属于构造函数的重载。

以上面的Complex类为例

//默认构造函数
Complex() 
//初始化的构造函数
Complex(double r,double i)
//用于复制对象的复制构造函数
Complex(const Complex &c)
//转换构造函数
Complex(double r){real=r;imag=0}
1
2
3
4
5
6
7
8
class Complex{
private:
    double real,imag;
public:
    Complex(double r,double i):real(r),imag(i){}
    Complex(double r){real = r;imag =0;}
    friend ostream& operator<<(ostream&,Complex&); //重载 << 插入运算符
};

ostream& operator<<(ostream& output,Complex& c)
{
    output<<"("<<c.real<<"+"<<c.imag<<"i"<<")"<<endl;
    return output;
}

int main(){
    Complex c1(1,10);
    Complex c2 = 3.0;
    cout<<c1;
    cout<<c2;
    return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
Complex c2 = 3.0; //转换构造函数
//相当于 Complex c2(3.0)
1
2
隐式转换常常会带来程序逻辑的错误，而且这种错误一旦发生是很难察觉的，应当尽量避免。
在声明构造函数的时候前面添加上explicit即可，这样就可以防止这种转换。C++中的explicit关键字只需用于修饰只有一个参数的类构造函数, 表明该构造函数是显示的, 而非隐式的， 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式)。

一旦声明为显式的(explicit)

//Complex c2 = 3.0; //违法
//只能这样写
Complex c2(3.0)
1
2
3
不仅可以将一个标准类型数据转换成类对象，也可以将另一个类的对象转换成类对象。

class B;
class A{
public:
    int x;
    A(int x):x(x){}
    A(B&);
};


class B{
public:
    int x;
    B(int x):x(x){}
};

A::A(B &b)
{
    x = b.x;
}

int main(){
    B b(1);
    A a = b;
    cout<<a.x<<endl;
    return 0;
}

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
类型转换函数
类型转换函数是在类中定义一个成员函数，将这个类的对象转换为另外一种类型的数据。

①转换函数必须是类的成员函数，不能是友元函数
②转换函数的调用是隐含的，没有参数，操作数是对象。
格式
operator <type>()
{……
	return <type>;
}


ClassName:: operator <type>()
{
	……
}
1
2
3
4
5
6
7
8
9
10
仍以Complex类为例

在这里插入代码片
1
class Complex{
private:
    double real,imag;
public:
    Complex(double r,double i):real(r),imag(i){}
    operator double();

};

Complex::operator double()
{
    cout<<"转换为复数的模长"<<endl;
    return sqrt(real*real+imag*imag);
}

int main(){
    Complex c(3,4);
    cout<<c<<endl; //这里就可以直接cout了，因为存在着类型转换
    return 0;
}
————————————————
原文链接：https://blog.csdn.net/qq_44846324/article/details/105831449

是运算符 单目 优先级是1
[ ]数组下标 ( )圆括号 .成员选择 ->成员选择 ++ --（后自增 自减）都是优先级为1的单目运算符

![image-20210817171548295](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817171548295.png)

![image-20210817171605656](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817171605656.png)

## 拷贝构造函数与赋值构造函数

https://www.cnblogs.com/liushui-sky/p/7728902.html

[C++中构造函数，拷贝构造函数和赋值函数的区别和实现](https://www.cnblogs.com/liushui-sky/p/7728902.html)

**C++中一般创建对象，拷贝或赋值的方式有构造函数，拷贝构造函数，赋值函数这三种方法。下面就详细比较下三者之间的区别以及它们的具体实现
**

#### **1.构造函数**

**构造函数是一种特殊的类成员函数，是当创建一个类的对象时，它被调用来对类的数据成员进行初始化和分配内存。（构造函数的命名必须和类名完全相同）**

首先说一下一个C++的空类，编译器会加入哪些默认的成员函数

**·默认构造函数和拷贝构造函数**

**·析构函数**

**·赋值函数（赋值运算符）**

**·取值函数**

***\*即使程序没定义任何成员，编译器也会插入以上的函数！ 
**

**注意：构造函数可以被重载，可以多个，可以带参数；**

**析构函数只有一个，不能被重载，不带参数**

 

**而默认构造函数没有参数，它什么也不做。当没有重载无参构造函数时，**

 **A a就是通过默认构造函数来创建一个对象**

下面代码为构造函数重载的实现

 

1. **class A** 
2. { 
3. int m_i; 
4. Public: 
5.  A()  
6. { 
7.  Cout<<”无参构造函数”<<endl; 
8. } 
9. A(int i):m_i(i) {} //初始化列表 
10. }</span> 

 

#### 2.拷贝构造函数

 

**拷贝构造函数是C++独有的，它是一种特殊的构造函数，用基于同一类的一个对象构造和初始化另一个对象。**

**当没有重载拷贝构造函数时，通过默认拷贝构造函数来创建一个对象**

**A a;**

**A b(a);**

**A b=a;  都是拷贝构造函数来创建对象b**

**强调：这里b对象是不存在的，是用a 对象来构造和初始化b的！！**

 

先说下什么时候拷贝构造函数会被调用：

**在C++中，3种对象需要复制，此时拷贝构造函数会被调用**

**1）一个对象以值传递的方式传入函数体**

**2）一个对象以值传递的方式从函数返回**

**3）一个对象需要通过另一个对象进行初始化**

 

**什么时候编译器会生成默认的拷贝构造函数：**

**1）如果用户没有自定义拷贝构造函数，并且在代码中使用到了拷贝构造函数，编译器就会生成默认的拷贝构造函数。但如果用户定义了拷贝构造函数，编译器就不在生成。**

**2）如果用户定义了一个构造函数，但不是拷贝构造函数，而此时代码中又用到了拷贝构造函数，那编译器也会生成默认的拷贝构造函数。**

 

因为系统提供的默认拷贝构造函数工作方式是内存拷贝，也就是浅拷贝。如果对象中用到了需要手动释放的对象，则会出现问题，这时就要手动重载拷贝构造函数，实现深拷贝。

**下面说说深拷贝与浅拷贝：**

浅拷贝：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用）

深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝。

**以上描述不详细，具体参见：http://www.cnblogs.com/liushui-sky/p/7728839.html**

 

拷贝构造函数重载声明如下： **
**

**A (const A&other)**

**下面为拷贝构造函数的实现：**

 

1. **class A** 
2. { 
3.  int m_i 
4.  A(**const A& other):m_i(other.m_i)** 
5. { 
6.  Cout<<”拷贝构造函数”<<endl; 
7. } 
8. }</span> 

#### 3.赋值函数

**当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。**

**当没有重载赋值函数（赋值运算符）时，通过默认赋值函数来进行赋值操作**

**A a;**

**A b;**

**b=a;** 

**强调：这里a,b对象是已经存在的，是用a 对象来赋值给b的！！**

 

赋值运算的重载声明如下：

 **A& operator = (const A& other)**

 

**通常大家会对拷贝构造函数和赋值函数混淆，这儿仔细比较两者的区别：**

**1）拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。**

 

1. **class A;** 
2. A a; 
3. A b=a;  //调用拷贝构造函数（b不存在） 
4. A c(a) ;  //调用拷贝构造函数 
5.  
6. /****/ 
7.  
8. **class A;** 
9. A a; 
10. A b;   
11. b = a ;  //调用赋值函数(b存在)</span> 

 

 

**2）一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象**

**3）实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。（这些要点会在下面的String实现代码中体现）**

 

**！！！如果不想写拷贝构造函数和赋值函数，又不允许别人使用编译器生成的缺省函数，最简单的办法是将拷贝构造函数和赋值函数声明为私有函数，不用编写代码。如：**

 

1. **class A** 
2. { 
3.  **private:** 
4.  A(**const A& a); //私有拷贝构造函数** 
5.  A& operate=(**const A& a); //私有赋值函数** 
6. }</span> 


如果程序这样写就会出错：

 

1. A a; 
2. A b(a); //调用了私有拷贝构造函数，编译出错 
3.  
4. A b; 
5. b=a; //调用了私有赋值函数，编译出错</span> 

 

**所以如果类定义中有指针或引用变量或对象，为了避免潜在错误，最好重载拷贝构造函数和赋值函数。**

 

**下面以string类的实现为例，完整的写了普通构造函数，拷贝构造函数，赋值函数的实现。[String类的基本实现](http://blog.csdn.net/zcyzsy/article/details/52146124)见我另一篇博文。**

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 String::String(const char* str)    //普通构造函数
 2 
 3 {
 4 
 5  cout<<construct<<endl;
 6 
 7  if(str==NULL)        //如果str 为NULL，就存一个空字符串“”
 8 
 9 {
10  m_string=new char[1];
11  *m_string ='\0';
12 }
13 
14  else
15 
16 {
17 
18   m_string= new char[strlen(str)+1] ;   //分配空间
19   strcpy(m_string,str);
20 
21 }
22 
23 }
24 
25  
26 String::String(const String&other)   //拷贝构造函数
27 
28 {
29  cout<<"copy construct"<<endl;
30  m_string=new char[strlen(other.m_string)+1]; //分配空间并拷贝
31  strcpy(m_string,other.m_string);
32 }
33 
34 String & String::operator=(const String& other) //赋值运算符
35 {
36  cout<<"operator =funtion"<<endl ;
37  if(this==&other) //如果对象和other是用一个对象，直接返回本身
38  {
39   return *this;
40  }
41  delete []m_string; //先释放原来的内存
42  m_string= new char[strlen(other.m_string)+1];
43  strcpy(m_string,other.m_string);
44  return * this;
45 }</span>
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**一句话记住三者：**

　　　　  **对象不存在，且没用别的对象来初始化，就是调用了构造函数；**

​        **对象不存在，且用别的对象来初始化，就是拷贝构造函数（上面说了三种用它的情况！）**

​        **对象存在，用别的对象来给它赋值，就是赋值函数。**

在C++中复制控制是一个比较重要的话题，主要包括复制构造函数、重载赋值操作符、析构函数这三部分，这三个函数是一致的，如果类需要析构函数，则它也需要复制操作符 和 复制构造函数，这个规则被称为 C++的“三法则”。如果需要手动定义了其中了一个，那么另外的两个也需要定义，通常在存在指针或者前期相关操作的情况下，都需要手动的定义。
        复制构造函数与重载赋值操作符实现的大题相同，如果没有手动的实现，那么编译器会自动生成一个，而且这两个函数的参数也是一致的，是不能够改变的。析构函数相比前面的两个存在一个巨大的差别，就是无论我们是否定义这个函数，编译器都会自动生成一个析构函数。析构函数主要是完成对象的释放操作。
        复制构造函数与重载赋值操作符在没有定义的情况下，编译器会为我们生成一个，这说明这两个函数是一个类必不可少的部分。由此可知如果一个类没有定义任何的东西，编译器也会帮助我们生成下面的4个函数：
1、一个构造函数，也就是所谓的类名比如classname(),这是在没有定义构造函数时，编译器会自动生成的。
2、析构函数，
3、复制构造函数。
4、重载赋值操作符。
假设存在一个类Base；
   class Base 
    {
        public:
            Base(); //构造函数
            Base(const Base &);  // 复制构造函数
            Base & operator = (const Base &);   // 赋值操作符
            ~Base();   // 析构函数
        private:
            .......
    };

现在对复制构造函数和赋值操作符做个详细的说明，下面是一个将要使用的例子；

class CExample
{
public :
     CExample(){pBuffer=NULL; nSize=0;}   //构造函数
     ~CExample(){delete pBuffer;}   // 析构函数
    void Init(int n){ pBuffer=new char [n]; nSize=n;}
private :
    char *pBuffer; //类的对象中包含指针,指向动态分配的内存资源
    int nSize;
};
    这个类的主要特点是包含指向其他资源的指针。 pBuffer指向堆中分配的一段内存空间。 
一、拷贝构造函数
int main(int argc, char * argv[])
{
     CExample A;
     A.Init40);
    
     CExample B=A; //把B初始化为A的副本
     ...
}
    B = A ; 此语句的具体过程:首先建立对象theObjtwo，并调用其构造函数，然后成员被拷贝。
    语句"CExample B=A;"  用 A 初始化 B。 其完成方式是内存拷贝，复制所有成员的值。 完成后，A.pBuffer = B.pBuffer,  即它们将指向同样的地方，指针虽然复制了，但所指向的空间并没有复制，而是由两个对象共用了。这样不符合要求，对象之间不独立了，并为空间的删除带来隐患。 所以需要采用必要的手段(拷贝构造函数)来避免此类情况。 


拷贝构造函数的格式为 : 构造函数名(对象的引用)  提供了拷贝构造函数后的CExample类定义为: 
class CExample
{
public :
     CExample(){pBuffer=NULL; nSize=0;}  //构造函数
     ~CExample(){delete pBuffer;}   // 析构函数
     CExample(const CExample&); //拷贝构造函数
    void Init(int n){ pBuffer=new char [n]; nSize=n;}
private :
    char *pBuffer; //类的对象中包含指针,指向动态分配的内存资源
    int nSize;
};

 //拷贝构造函数的定义
CExample::CExample(const CExample& RightSides)
{
     nSize=RightSides.nSize;    //复制常规成员
     pBuffer=new char [nSize];    //复制指针指向的内容
     memcpy(pBuffer,RightSides.pBuffer,nSize*sizeof (char ));
}
     这样，定义新对象，并用已有对象初始化新对象时，即执行语句“CExample B=A; ” 时，CExample(const CExample& RightSides)将被调用，而已有对象用别名RightSides传给构造函数，以用来作复制。原则上，应该为所有包含动态分配成员的类都提供拷贝构造函数。 

拷贝函数被调用的情况有：
1，定义新对象，并用已有对象初始化新对象时； 即执行语句“CExample B=A; ” 时（定义对象时使用赋值初始化）；
2，当对象直接作为参数传给函数时，函数将建立对象的临时拷贝，这个拷贝过程也将调同拷贝构造函数。 
    例如：
        BOOL testfunc(CExample obj)
        {
             //针对obj的操作实际上是针对复制后的临时拷贝进行的
        }
        testfunc(theObjone); //对象直接作为参数，拷贝函数将被调用；
3，当函数中的局部对象被返回给函数调者时，也将建立此局部对象的一个临时拷贝，拷贝构造函数也将被调用 ；
    例如：
    CTest func()
    {
         CTest   theTest;
         return   theTest
     }  

二、赋值符的重载 
    下面的代码与上例相似
int main(int argc, char * argv[])
{
     CExample A;
     A.Init(40);
    
     CExample C;
     C.Init(60);


      //现在需要一个对象赋值操作,被赋值对象的原内容被清除，并用右边对象的内容填充。
     C = A;
    return 0;
}
     也用到了"="号，但与上面的例子中语句“ CExample B=A;  ” 不同“ CExample B=A;  ”语句中的 "=" 在对象声明语句中，表示初始化。更多时候,这种初始化也可用括号表示。 例如 CExample B(A); 

     而本例子中，"=" 表示赋值操作。将对象 A 的内容复制到对象C;，这其中涉及到对象C 原有内容的丢弃，新内容的复制。 但"="的缺省操作只是将成员变量的值相应复制。旧的值被自然丢弃。 由于对象内包含指针，将造成不良后果:指针的值被丢弃了，但指针指向的内容并未释放。指针的值被复制了，但指针所指内容并未复制。 因此，包含动态分配成员的类除提供拷贝构造函数外，还应该考虑重载"="赋值操作符号。 

类定义变为: 
class CExample
{
public :
     CExample(){pBuffer=NULL; nSize=0;}  //构造函数
     ~CExample(){delete pBuffer;}   // 析构函数
     CExample(const CExample&); //拷贝构造函数
     CExample& operator = (const CExample&); //赋值符重载
    void Init(int n){ pBuffer=new char [n]; nSize=n;}
private :
    char *pBuffer; //类的对象中包含指针,指向动态分配的内存资源
    int nSize;
};
//赋值操作符重载
CExample & CExample::operator = (const CExample& RightSides)
{
     nSize=RightSides.nSize; //复制常规成员
    char *temp=new char [nSize]; //复制指针指向的内容 
     memcpy(temp,RightSides.pBuffer,nSize*sizeof (char ));

    delete []pBuffer; //删除原指针指向内容   (将删除操作放在后面，避免X=X特殊情况下，内容的丢失)
     pBuffer=temp;    //建立新指向
    return *this 
}
三、拷贝构造函数使用赋值运算符重载的代码。 
CExample::CExample(const CExample& RightSides)
{
     pBuffer=NULL;
     *this =RightSides      //调用重载后的"="
}

    为了更好地理解拷贝构造函数   
 1、为什么要有拷贝构造函数，它跟构造函数有什么区别？
       答：拷贝构造函数其实也是构造函数，只不过它的参数是const 的类自身的对象的引用。如果类里面没有指针成员（该指针成员指向动态申请的空间），是没有必要编写拷贝构造函数的 。     我们知道，如果有一个类CObj，它已经产生了一个对象ObjA，现在又用CObj去创建ObjB，如果程序中使用语句ObjB = ObjA; 也就是说直接使用ObjA的数据给ObjB赋值。这对于一般的类，没有任何问题，但是如果CObj里面有个char * pStr的成员，用来存放动态申请的字符串的地址，在ObjA中使用new 方法动态申请了内存并让ObjA.pStr指向该申请的空间，在OjbB = OjbA之后，ObjA.pStr和ObjB.pStr将同时指向那片空间，这样到导致了谁也不知道到底该由谁来负责释放那块空间，很有可能导致同一块内存被释放两次。     使用拷贝构造函数，先申请ObjA.pStr所指向的空间大小的空间，然后将空间内容拷贝过来，这样就不会同时指向同一块内存，各自有各自申请的内存，各自负责释放各自申请的内存，从而解决了刚才的问题。所以这里的“拷贝”拷贝的是动态申请的空间的内容，而不是类本身的数据。另外注意到，拷贝构造函数的参数是对象的引用，而不是对象的指针。至于为什么要用引用，不能够用指针暂时还没有搞明白，等搞明白了再说。    
2、为什么要对=赋值操作符进行重载？
    答：接上面的例子，用户在使用语句ObjB = ObjA的时候，或许ObjB的pStr已经指向了动态申请的空间，如果直接简单将其指向的地址覆盖，就会导致内存泄露，所以需要对=赋值操作符进行重载，在重载函数中判断pStr如果已经指向了动态申请的空间，就先将其释放。    
3、拷贝构造函数和=赋值操作符重载的关系。
    答：从原文的例子中可以看出，=赋值操作符重载比拷贝构造函数做得要多，它除了完成拷贝构造函数所完成的拷贝动态申请的内存的数据之外，还释放了原本自己申请的内存空间。所以原文最后给出的拷贝构造函数的实现可以使用=赋值操作符的重载来完成。    
4、拷贝构造函数何时被调用？
    a.对象的直接赋值也会调用拷贝构造函数  ；
    b.函数参数传递只要是按值传递也调用拷贝构造函数；
    c.函数返回只要是按值返回也调用拷贝构造函数。 

 四、拷贝构造函数 和 赋值运算符重载 为什么要使用引用？ 
    首先先说下基类 和 派生类的关系：
    例如：
        class Derived：public Base
        {
            public：
              .....
            private：
                .......
        }；

 不同继承方式的基类和派生类特性

继承方式	基类特性	派生类特性
公有继承	public	public
protected
private	protected
不可访问
私有继承	public	private
protected
private	private
不可访问
保护继承	public	protected
protected
private	protected
不可访问

        首先，派生类对象的引用初始化基类引用。多态性的动态绑定中存在两个条件：1，必须是virtual 函数（虚函数）；2， 必须是通过基类的引用或基类的指针进行成员函数的调用。


    由于派生类中存在基类的成员，也就相当于一个派生类对象中包含了一个基类对象，所以可以采用一个基类引用来绑定一个派生类对象。引用实质上是针对一块内存区域，引用是一个标号，是这块内存区域的一个名字，一个引用与一块内存区域绑定，因为派生对象中存在基类部分，可以认为派生对象的区域中存在基类对象，这时可用基类的引用来表明这块内存区域，即采用一个基类的别名来表示（绑定）这段内存区域，派生对象的地址（这段内存）以及内容都没有发生改变，也没有重现创造出一个新的对象，基类的引用还是指向这个派生对象。对于指针的分析方式相似。因此可以采用基类的引用绑定派生类对象。

   


    但是如何实现派生类对象到基类的转换呢？
    
    这时候的转换与前面的绑定存在很大的差别，因为这是重新分配一个基类对象，而不再是引用问题，不再是绑定问题，是依据一个派生类对象生成一个新的基类对象。因为派生类对象中存在一个基类对象基本的信息，完全可以生成一个基类对象，完全将此过程看作是一个初始化或者赋值的问题。也就是采用派生类创建一个新的对象或者赋值一个对象。
    
    从上面的分析我们可以采用下面的形式来实现：
     Base(const Derived &);
     Base &operator=(const Derived &);
    
    是在基类函数中采用构造函数基于派生类来重载一系列的构造函数，但是这也存在一个问题，如果存在很多派生类，这时候就要重载很多构造函数，这肯定不是我们需要的。

 


    这时候我们发现对于一个类而言，为什么复制构造函数和重载赋值操作符这么重要了。因为这两个函数都是接受一个基类的引用，根据前面的分析我们知道一个基类引用完全可以绑定一个派生类的对象，而派生类对象中又包含了一个基类对象的基本信息。我们能够实现一个从一个派生对象到基类的构造过程。
    我们用一个基类引用绑定一个派生对象，然后采用基类引用对基类成员进行访问，完成了一个基类对象基本要素的填充操作，相当于完成了基类对象的创建，也就是构造问题。这样也就能完成由派生类对象到基类对象的构造过程。

 


    总结起来说了，因为在复制构造函数中，C++中的基类引用可以绑定一个派生类的对象，如果在允许访问的情况下，采用基类引用可以访问基类的成员以及派生类的其他成员，采用引用可以复制派生类对象中基类成员的值到新创建的基类成员中，完成一个基类成员数据的填充操作，这时候一个完整的基类对象就创建完成了。

 


    重载赋值操作符则是发生在使用一个派生对象来赋值一个基类对象时，这时候也是const基类引用绑定一个派生类对象，然后复制对应的基类成员到基类对象对于的成员中，完成一个基类对象成员的更新操作。

 


    复制构造函数不仅仅实现了同类型之间的初始化操作，同时也完成了采用一个派生类对象初始化一个基类对象的操作，重载赋值操作符实现了同类型之间的赋值操作，也完成了采用派生类对象赋值基类对象的操作。如果没有这两个函数的存在，也就不能完成派生类到基类的赋值和初始化操作。这也是为什么一定会存在这两个函数的原因。

原文链接：https://blog.csdn.net/qq_36553031/article/details/89057433

# 虚函数

virtual关键字

![image-20210817172328341](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817172328341.png)

![image-20210817172435083](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817172435083.png)

![image-20210817172754484](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817172754484.png)

## 内联函数

**内联函数inline：**引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：

- 1.在内联函数内不允许使用循环语句和开关语句；

- 2.内联函数的定义必须出现在内联函数第一次调用之前；

- 3.类结构中所在的类说明内部定义的函数是内联函数。

- C++ **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

  对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

  如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 **inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

  在类定义中的定义的函数都是内联函数，即使没有使用 **inline** 说明符。

  下面是一个实例，使用内联函数来返回两个数中的最大值：

  ```
  #include <iostream>
   
  using namespace std;
  
  inline int Max(int x, int y)
  {
     return (x > y)? x : y;
  }
  
  // 程序的主函数
  int main( )
  {
  
     cout << "Max (20,10): " << Max(20,10) << endl;
     cout << "Max (0,200): " << Max(0,200) << endl;
     cout << "Max (100,1010): " << Max(100,1010) << endl;
     return 0;
  }
  ```

  当上面的代码被编译和执行时，它会产生下列结果：

  ```
  Max (20,10): 20
  Max (0,200): 200
  Max (100,1010): 1010
  ```

Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.

定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.

优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.

缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。

结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!

另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).

有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.

## **CPP 虚函数、虚函数表及虚拟继承（转）**

1、虚函数

- **虚函数的定义**：  

 虚函数必须是类的非静态成员函数(且非构造函数)，其访问权限是public（可以定义为private or proteceted, 但是对于多态来说，没有意义），在基类的类定义中定义虚函数的一般形式：
virtual 函数返回值类型 虚函数名（形参表）
{ 函数体 }

- **定义虚函数的限制**：

（1）非类的成员函数不能定义为虚函数，类的成员函数中静态成员函数和构造函数也不能定义为虚函数，但可以将析构函数定义为虚函数。
 实际上，优秀的程序员 常常把基类的析构函数定义为虚函数。因为，将基类的析构函数定义为虚函数后，当利用delete删除一个指向派生类定义的对象指针时，系统会调用相应的类的析构函数。而不将析构函数定义为虚函数时，只调用基类的析构函数。
（2）只需要在声明函数的类体中使用关键字“virtual”将函数声明为虚函数，而定义函数时不需要使用关键字“virtual”。
（3）如果声明了某个成员函数为虚函数，则在该类中不能出现和这个成员函数同名并且返回值、参数个数、参数类型都相同的非虚函数。在以该类为基类的派生类中，也不能出现这种非虚的同名同返回值同参数个数同参数类型函数。

- **为什么虚函数必须是类的成员函数**：

 虚函数诞生的目的就是为了实现多态，在类外定义虚函数毫无实际用处。

- **为什么类的静态成员函数不能为虚函数**：

  如果定义为虚函数，那么它就是动态绑定的，也就是在派生类中可以被覆盖的，这与静态成员函数的定义（在内存中只有一份拷贝；通过类名或对象引用访问静态成员）本身就是相矛盾的。

- **为什么构造函数不能为虚函数**：

 因为如果构造函数为虚函数的话，它将在执行期间被构造，而执行期则需要对象已经建立，构造函数所完成的工作就是为了建立合适的对象，因此在没有构建好的对象上不可能执行多态（虚函数的目的就在于实现多态性）的工作。在继承体系中，构造的顺序就是从基类到派生类，其目的就在于确保对象能够成功地构建。构造函 数同时承担着虚函数表的建立，如果它本身都是虚函数的话，如何确保V-Table的构建成功呢？

注意：当基类的构造函数内部有虚函数时，会出现什么情况呢？结果是在构造函数中，虚函数机制不起作用了，调用虚函数如同调用一般的成员函数一样。

当基类的析构函数内部有虚函数时，又如何工作呢？与构造函数相同，只有“局部”的版本被调用。但是，行为相同，原因是不一样的。构 造函数只能调用“局部”版本，是因为调用时还没有派生类版本的信息。析构函数则是因为派生类版本的信息已经不可靠了。我们知道，析构函数的调用顺序与构造 函数相反，是从派生类的析构函数到基类的析构函数。当某个类的析构函数被调用时，其派生类的析构函数已经被调用了，相应的数据也已被丢失，如果再调用虚函 数的派生类的版本，就相当于对一些不可靠的数据进行操作，这是非常危险的。因此，在析构函数中，虚函数机制也是不起作用的。

 C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。 这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。**
****2.** 虚函数表

  对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。 这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

 这里我们着重看一下这张虚函数表。在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

  假设我们有这样的一个类：

class Base {

public:

virtual void f() { cout << "Base::f" << endl; }

virtual void g() { cout << "Base::g" << endl; }

virtual void h() { cout << "Base::h" << endl; }

};

按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：

typedef void(*Fun)(void);

Base b;

Fun pFun = NULL;

cout << "虚函数表地址：" << (int*)(&b) << endl;

cout << "虚函数表 — 第一个函数地址：" << (int*)*(int*)(&b) << endl;

// Invoke the first virtual function

pFun = (Fun)*((int*)*(int*)(&b));

pFun();

实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3)

虚函数表地址：0012FED4

虚函数表 — 第一个函数地址：0044F148

Base::f

通过这个示例，我们可以看到，我们可以通过强行把&b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：

(Fun)*((int*)*(int*)(&b)+0); // Base::f()

(Fun)*((int*)*(int*)(&b)+1); // Base::g()

(Fun)*((int*)*(int*)(&b)+2); // Base::h()

这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示：

![[转载]虚函数，虚表，虚继承](http://fmn.rrfmn.com/fmn048/20110427/2135/b_large_d3en_52c00001fbeb5c43.jpg)

 

注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。

下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。

\3. 一般继承（无虚函数覆盖）
下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：

 ![[转载]虚函数，虚表，虚继承](http://fmn.rrfmn.com/fmn051/20110427/2140/b_large_zaOU_32e700003cab5c41.jpg)

请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：

对于实例：Derive d; 的虚函数表如下：

 ![[转载]虚函数，虚表，虚继承](http://fmn.rrfmn.com/fmn048/20110427/2140/b_large_Dqit_5ccb000006f05c44.jpg)

我们可以看到下面几点：

1）虚函数按照其声明顺序放于表中。

2）父类的虚函数在子类的虚函数前面。

我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。

**4. 一般继承（有虚函数覆盖）**
  覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。

 ![[转载]虚函数，虚表，虚继承](http://fmn.rrfmn.com/fmn048/20110427/2140/b_large_i1SW_17e4000016925c3f.jpg)

  为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：

 ![[转载]虚函数，虚表，虚继承](http://fmn.xnpic.com/fmn050/20110427/2140/b_large_C9zM_1d8c00011e315c71.jpg)

我们从表中可以看到下面几点，

1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。

2）没有被覆盖的函数依旧。

这样，我们就可以看到对于下面这样的程序，

Base *b = new Derive();

b->f();

由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。

\5. 多重继承（无虚函数覆盖）

下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。

![C++中的虚函数（转）](http://p.blog.csdn.net/p_w_picpaths/p_blog_csdn_net/haoel/15190/o_Drawing1.jpg)

 ![[转载]虚函数，虚表，虚继承](http://fmn.rrfmn.com/fmn054/20110427/2140/b_large_eBTt_1a870001f5805c40.jpg)

对于子类实例中的虚函数表，是下面这个样子：

![C++中的虚函数（转）](http://p.blog.csdn.net/p_w_picpaths/p_blog_csdn_net/haoel/15190/o_vtable4.JPG)

我们可以看到：

1） 每个父类都有自己的虚表。

2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）

这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。

**6. 多重继承（有虚函数覆盖）**
下面我们再来看看，如果发生虚函数覆盖的情况。

下图中，我们在子类中覆盖了父类的f()函数。

 ![[转载]虚函数，虚表，虚继承](http://fmn.rrfmn.com/fmn051/20110427/2140/b_large_7c0W_1d820000babb5c71.jpg)

下面是对于子类实例中的虚函数表的图：

 ![[转载]虚函数，虚表，虚继承](http://fmn.rrfmn.com/fmn046/20110427/2140/b_large_p3CQ_18200001ee5c5c3f.jpg)

我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：

Derive d;

Base1 *b1 = &d;

Base2 *b2 = &d;

Base3 *b3 = &d;

b1->f(); //Derive::f()

b2->f(); //Derive::f()

b3->f(); //Derive::f()

b1->g(); //Base1::g()

b2->g(); //Base2::g()

b3->g(); //Base3::g()

安全性
每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。

一、通过父类型的指针访问子类自己的虚函数

我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：

Base1 *b1 = new Derive();

b1->f1(); //编译出错

任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）

二、访问non-public的虚函数

另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。

如：

class Base {

private:

virtual void f() { cout << "Base::f" << endl; }

};

class Derive : public Base{

};

typedef void(*Fun)(void);

void main() {

Derive d;

Fun pFun = (Fun)*((int*)*(int*)(&d)+0);

pFun();

}

三。虚继承

虚继承的出现一方面是为了消除二义性，另一方面是为了节省空间。

对于子类虚拟继承父类而言，子类对象需要维护一个虚拟指针指向其父类。

如果出现存在虚函数的父类的虚拟继承怎么办呢?这是内存怎么操作的呢？

看下面这张图很明显

 

我们可以看出，子类不仅维持了指向父类的虚函数表的虚指针，同时还维护了指向父类的虚拟指针，即派生类需要维护两个虚拟指针。

## 虚析构函数

让使用者通过访问基类指针调用派生类对象的析构函数，通过delete这样做时正常的，让析构函数成为虚函数。

![image-20210817194121457](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817194121457.png)

![image-20210817194319522](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817194319522.png)

![image-20210817194623374](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817194623374.png)

## 虚表与动态绑定

**![image-20210817194800773](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817194800773.png)**

![image-20210817194815284](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817194815284.png)

每个类隐含的存在一个指向虚表的指针。从虚表找到指针指向的对象。

![image-20210817195059689](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817195059689.png)

纯虚函数，为了规定类的统一接口。

函数没有函数体。

抽象类，具有纯虚函数的类。不能够实例化

![image-20210817195208401](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817195208401.png)

![image-20210817195309769](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817195309769.png)

![image-20210817195449384](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817195449384.png)

![image-20210817195618686](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817195618686.png)

![image-20210817195638140](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817195638140.png)

override

final函数不被修改，不能被覆盖。

# 模板

## 函数模板

![image-20210817200112098](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817200112098.png)

![image-20210817200918944](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817200918944.png)

![image-20210817200956478](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817200956478.png)

自定义类型，需要重载运算符。

## 类模板

![image-20210817201121475](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817201121475.png)

template<模板参数表>

class 类名

{
类成员声明}![image-20210817201241263](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817201241263.png)

![image-20210817201343859](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817201343859.png)

![image-20210817201417412](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817201417412.png)

## 数组类模板

![image-20210817202913206](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817202913206.png)

![image-20210817202030305](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817202030305.png)

![image-20210817202332756](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817202332756.png)

![image-20210817202343989](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817202343989.png)

![image-20210817202442873](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817202442873.png)

![image-20210817202527903](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817202527903.png)

![image-20210817202719379](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817202719379.png)

# 泛型程序设计

![image-20210817203314413](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817203314413.png)

使得算法成为通用的

![image-20210817203404641](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817203404641.png)

![image-20210817203453095](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817203453095.png)

![image-20210817203530168](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817203530168.png)

![image-20210817203557271](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817203557271.png)

需要包含头文件

迭代器是泛化的指针

![image-20210817203632395](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817203632395.png)

![image-20210817203707967](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817203707967.png)

![image-20210817203722359](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817203722359.png)

#include<bits/stdc++.h>

![image-20210817203859711](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817203859711.png)

# 流与输入输出

流是信息的抽象

![image-20210817210459775](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817210459775.png)

![image-20210817210543228](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817210543228.png)

## 输出流

<img src="C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817210615631.png" alt="image-20210817210615631" style="zoom:80%;" />

![image-20210817210808411](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817210808411.png)

![image-20210817210906294](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817210906294.png)

输出格式，操纵符

iomanip头文件，setprecision设置精度



![image-20210817211609142](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817211609142.png)

![image-20210817211650989](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817211650989.png)

![image-20210817211734969](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817211734969.png)

设置左右对齐

(setiosflagsios_base::left)

（resetiosflags(ios_base::left)）

![image-20210817211836581](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817211836581.png)

![image-20210817212006713](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817212006713.png)

设置输出精度

ios_base::fixed,ios_base::scientific

设置一位有效数据

![image-20210817212054131](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817212054131.png)

顶点输出

![image-20210817212158703](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817212158703.png)

设置科学计数法

小数位数为1

![image-20210817212210489](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817212210489.png)

## 二进制文件输出

![image-20210817212402088](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817212402088.png)

指针，字节数

reinterpret——cast临时转换为指针类型

## 字符串输出流

不是真实的文件

![image-20210817212536216](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817212536216.png)

数值转字符串

![image-20210817212619540](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817212619540.png)

tostring可以支持将各种插入符的类型转换为i字符串

str（）函数返回输出流生成的字符串

## 输入流

![image-20210817212938986](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817212938986.png)

![image-20210817213017155](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817213017155.png)

为类重载为非成员函数

dec十进制，oct八进制,hex十六进制。

![image-20210817213215314](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817213215314.png)

文件结束符

## 字符串输入流

![image-20210817213322309](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817213322309.png)

将字符串转换为其他类型

![image-20210817213400779](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817213400779.png)

# 异常处理

![image-20210817213644477](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817213644477.png)

![image-20210817213721255](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817213721255.png)

![image-20210817213758247](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817213758247.png)

![image-20210817213931048](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817213931048.png)

异常处理的构造与析构

try一旦发生异常，后面不会执行

![image-20210817214101122](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817214101122.png)

![image-20210817214142172](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817214142172.png)

![image-20210817214153456](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817214153456.png)

标准库异常处理

![image-20210817214321492](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817214321492.png)

![image-20210817214330091](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817214330091.png)

![image-20210817214346973](C:\Users\qdd123\AppData\Roaming\Typora\typora-user-images\image-20210817214346973.png)

